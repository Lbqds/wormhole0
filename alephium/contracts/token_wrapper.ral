import "token_bridge.ral"
import "token_bridge_for_chain.ral"
import "math.ral"

TxContract TokenWrapper(
    tokenBridgeId: ByteVec,
    tokenBridgeForChainId: ByteVec,
    localChainId: U256,
    tokenChainId: U256,
    tokenContractId: ByteVec,
    decimals: U256,
    symbol: ByteVec,
    name: ByteVec
) {
    pub payable fn transfer(
        fromAddress: Address,
        toAddress: ByteVec,
        amount: U256,
        arbiterFee: U256,
        nonce: ByteVec,
        consistencyLevel: U256
    ) -> () {
        assert!(size!(toAddress) == 32)
        assert!(size!(nonce) == 4)
        assert!(size!(tokenContractId) == 32)

        let math = Math(#{{ mathAddress }})
        let normalizedAmount = math.normalizeAmount(amount, decimals)
        let normalizedFee = math.normalizeAmount(arbiterFee, decimals)
        assert!(normalizedFee < normalizedAmount)

        let transferAmount = math.deNormalizeAmount(normalizedAmount, decimals)
        transferTokenToSelf!(fromAddress, selfContractId!(), transferAmount)

        let payload = #01 ++ // payloadId
            u256To32Byte!(normalizedAmount) ++
            tokenContractId ++
            u256To2Byte!(tokenChainId) ++
            toAddress ++
            u256To2Byte!(tokenChainId) ++
            u256To32Byte!(normalizedFee)

        let tokenBridge = TokenBridge(tokenBridgeId)
        approveAlph!(fromAddress, tokenBridge.getMessageFee())
        tokenBridge.publishTransferWrapped(fromAddress, payload, nonce, consistencyLevel)
    }

    pub payable fn completeTransfer(vaa: ByteVec, arbiter: Address) -> () {
        let tokenBridgeForChain = TokenBridgeForChain(tokenBridgeForChainId)
        let (wrappedTokenId, wrappedTokenChainId, recipientAddress, amount, arbiterFee) = tokenBridgeForChain.parseTransfer(vaa)
        assert!(wrappedTokenId == tokenContractId)
        assert!(wrappedTokenChainId == tokenChainId)

        let math = Math(#{{ mathAddress }})
        let denomalizedAmount = math.deNormalizeAmount(amount, decimals)
        let denomalizedFee = math.deNormalizeAmount(arbiterFee, decimals)
        assert!(denomalizedAmount > denomalizedFee)

        let transferAmount = denomalizedAmount - denomalizedFee
        let tokenId = selfContractId!()
        let recipient = byteVecToAddress!(#00 ++ recipientAddress)
        transferAlphFromSelf!(recipient, 1000000000000) // dustAmount
        transferTokenFromSelf!(recipient, tokenId, transferAmount)
        transferTokenFromSelf!(arbiter, tokenId, denomalizedFee)
    }

    pub payable fn deposit(from: Address, amount: U256) -> () {
        transferAlphToSelf!(from, amount)
    }
}
